#!/bin/bash
# Bastion Firewall - Inbound Protection Setup
# This script sets up minimal INPUT chain rules if no other firewall is detected.
# Called by systemd service at startup.

set -e

BASTION_COMMENT="BASTION_INBOUND"
CONFIG_FILE="/etc/bastion/config.json"
STATE_FILE="/var/run/bastion/inbound-active"

log() {
    echo "bastion-setup-inbound: $1"
}

# Check if inbound protection is disabled in config
check_config() {
    if [ -f "$CONFIG_FILE" ]; then
        INBOUND_ENABLED=$(grep -o '"inbound_protection"[[:space:]]*:[[:space:]]*\(true\|false\)' "$CONFIG_FILE" 2>/dev/null | grep -o '\(true\|false\)' || echo "true")
        if [ "$INBOUND_ENABLED" = "false" ]; then
            log "Inbound protection disabled in config"
            exit 0
        fi
    fi
}

# Check if UFW is active
check_ufw() {
    if command -v ufw &>/dev/null; then
        if ufw status 2>/dev/null | grep -q "Status: active"; then
            log "UFW is active - skipping Bastion inbound rules"
            exit 0
        fi
    fi
}

# Check if firewalld is active
check_firewalld() {
    if systemctl is-active firewalld &>/dev/null; then
        log "firewalld is active - skipping Bastion inbound rules"
        exit 0
    fi
}

# Check if nftables has actual DROP/REJECT rules in input chain
check_nftables() {
    if command -v nft &>/dev/null; then
        # Look for actual blocking rules, not just empty chains
        # iptables-nft creates chains but they may be empty when UFW is disabled
        if nft list ruleset 2>/dev/null | grep -E "chain input|chain INPUT" | grep -qi "drop\|reject" 2>/dev/null; then
            log "nftables input chain with blocking rules detected - skipping Bastion inbound rules"
            exit 0
        fi
        # Also check for explicit drop policy
        if nft list ruleset 2>/dev/null | grep -E "chain input|chain INPUT" -A5 | grep -qi "policy drop" 2>/dev/null; then
            log "nftables input chain with drop policy detected - skipping Bastion inbound rules"
            exit 0
        fi
    fi
    return 0
}

# Check for existing iptables INPUT rules that actually block traffic
check_iptables_rules() {
    # Look for DROP or REJECT rules in INPUT chain (not just ACCEPT or chain jumps)
    BLOCKING_RULES=$(iptables -L INPUT -n 2>/dev/null | grep -E "DROP|REJECT" | grep -v "$BASTION_COMMENT" | wc -l || echo "0")
    if [ "$BLOCKING_RULES" -gt 0 ]; then
        log "Existing iptables INPUT blocking rules detected ($BLOCKING_RULES rules) - skipping"
        exit 0
    fi

    # Also check INPUT chain policy
    INPUT_POLICY=$(iptables -L INPUT -n 2>/dev/null | head -1 | grep -oE '\(policy [A-Z]+\)' | grep -oE 'DROP|REJECT' || true)
    if [ -n "$INPUT_POLICY" ]; then
        log "iptables INPUT chain has $INPUT_POLICY policy - skipping"
        exit 0
    fi
}

# Check if our rules are already in place
check_existing_bastion_rules() {
    if iptables -L INPUT -n 2>/dev/null | grep -q "$BASTION_COMMENT"; then
        # Ensure state file exists (may be missing after reboot)
        mkdir -p /var/run/bastion
        echo "active" > "$STATE_FILE"
        chmod 644 "$STATE_FILE"
        log "Bastion inbound rules already configured"
        exit 0
    fi
}

# Set up minimal INPUT rules
setup_rules() {
    log "Setting up minimal inbound protection..."

    # IPv4 rules
    iptables -A INPUT -i lo -m comment --comment "$BASTION_COMMENT" -j ACCEPT
    iptables -A INPUT -m state --state ESTABLISHED,RELATED -m comment --comment "$BASTION_COMMENT" -j ACCEPT
    iptables -A INPUT -p icmp --icmp-type echo-request -m comment --comment "$BASTION_COMMENT" -j ACCEPT
    iptables -A INPUT -m comment --comment "$BASTION_COMMENT" -j DROP

    # IPv6 rules (if ip6tables available)
    if command -v ip6tables &>/dev/null; then
        ip6tables -A INPUT -i lo -m comment --comment "$BASTION_COMMENT" -j ACCEPT 2>/dev/null || true
        ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -m comment --comment "$BASTION_COMMENT" -j ACCEPT 2>/dev/null || true
        ip6tables -A INPUT -p icmpv6 -m comment --comment "$BASTION_COMMENT" -j ACCEPT 2>/dev/null || true
        ip6tables -A INPUT -m comment --comment "$BASTION_COMMENT" -j DROP 2>/dev/null || true
    fi

    # Create state file so GUI can detect protection without root
    mkdir -p /var/run/bastion
    echo "active" > "$STATE_FILE"
    chmod 644 "$STATE_FILE"

    log "Bastion inbound protection enabled"
    log "  Allowing: localhost, established connections, ICMP ping"
    log "  Blocking: all other unsolicited inbound connections"
}

# Main
check_config
check_ufw
check_firewalld
check_nftables
check_iptables_rules
check_existing_bastion_rules
setup_rules

exit 0

